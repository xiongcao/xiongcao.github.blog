title: 浏览器相关原理详细总结一
author: 熊 超
tags:
  - 浏览器
categories:
  - 浏览器
date: 2019-02-18 14:45:00
---
<!-- more --> 

# 浏览器相关原理详细总结一

## Chrome 打开一个页面需要启动多少进程？分别有哪些进程？

浏览器从关闭状态进行启动，然后新开 **1** 个页面至少需要 **1 个网络进程**、**1 个浏览器进程**、**1 个 GPU 进程**以及 **1 个渲染进程**，共 **4** 个进程；后续再新开标签页，浏览器、网络进程、**GPU**进程是共享的，不会重新启动，如果**2**个页面属于同一站点的话，并且从**a**页面中打开的**b**页面，那么他们也会共用一个渲染进程，否则新开一个渲染进程。

最新的 **Chrome** 浏览器包括：**1** 个浏览器（**Browser**）主进程、1 个 **GPU** 进程、**1** 个网络（**NetWork**）进程、多个渲染进程和多个插件进程。

- `浏览器进程`：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

- `渲染进程`：核心任务是将 **HTML**、**CSS** 和 **JavaScript** 转换为用户可以与之交互的网页，排版引擎 **Blink** 和 **JavaScript** 引擎 **V8** 都是运行在该进程中，默认情况下，**Chrome** 会为每个 **Tab** 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

- `GPU 进程`：其实，**Chrome** 刚开始发布的时候是没有 **GPU** 进程的。而 **GPU** 的使用初衷是为了实现 **3D CSS** 的效果，只是随后网页、**Chrome** 的 **UI** 界面都选择采用 **GPU** 来绘制，这使得 **GPU** 成为浏览器普遍的需求。最后，**Chrome** 在其多进程架构上也引入了 **GPU** 进程。

- `网络进程`：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。

- `插件进程`：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

## 如何保证页面文件能被完整送达浏览器？

互联网中的数据是通过数据包来传输的。数据包要在互联网上进行传输，就要符合网际协议(IP)，互联网上不同的在线设备都有唯一的地址，地址只是一个数字，只要知道这个具体的地址，就可以往这里发送信息。

如果要想把一个数据包从主机 **A** 发送给主机 **B**，那么在传输之前，数据包上会被附加上主机 **B** 的 **IP** 地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机 **A** 本身的 **IP** 地址，有了这些信息主机 **B** 才可以回复信息给主机 **A**。这些附加的信息会被装进一个叫 **IP** 头的数据结构里。**IP** 头是 **IP** 数据包开头的信息，包含 **IP 版本**、**源 IP 地址**、**目标 IP 地址**、**生存时间**等信息。

**IP** 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给王者荣耀？？因此，需要基于 **IP** 之上开发能和应用打交道的协议，最常见的是`用户数据包协议（User Datagram Protocol)，简称UDP`和`传输控制协议（Transmission Control Protocol）,简称TCP`。

基本传输过程为：

1. 上层将数据包交给传输层；
2. 传输层会在数据包前面附加上`UDP 头`，组成新的 **UDP** 数据包，再将新的 **UDP** 数据包交给网络层；
3. 网络层再将 **IP** 头附加到数据包上，组成新的 **IP** 数据包，并交给底层；
4. 数据包被传输到主机 **B** 的网络层，在这里主机 **B** 拆开 **IP** 头信息，并将拆开来的数据部分交给传输层；
5. 在传输层，数据包中的 **UDP** 头会被拆开，并根据 **UDP** 中所提供的端口号，把数据部分交给上层的应用程序
6. 最终，数据包就发送到了主机 **B** 上层应用程序这里。

## UDP和TCP有什么区别？

- **TCP**协议在传送数据段的时候要给段标号；**UDP**协议不；
- **TCP**协议可靠；UDP协议不可靠；
- **TCP**协议是面向连接；UDP协议采用无连接；
- **TCP**协议负载较高，采用虚电路；**UDP**采用无连接；
- **TCP**协议的发送方要确认接收方是否收到数据段（**3次握手协议**）；
- **TCP**协议采用窗口技术和流控制。

| **特性** | **TCP** | **UDP** |
| ------ | ------- | ------- |
| 是否连接   | 面向连接    | 面向非连接   |
| 传输可靠性  | 可靠      | 不可靠     |
| 应用场合   | 传输大量数据  | 传输少量数据  |
| 速度     | 慢       | 快       |

## TCP传输的详细过程是怎样的？

#### 进行三次握手，建立TCP连接。

<img src="/Users/xiongchao/Library/Application Support/typora-user-images/image-20230410171031799.png" alt="image-20230410171031799" style="zoom:50%;" />

- 第一次握手：建立连接。客户端发送连接请求报文段，将**SYN**位置为1，**Sequence Number**为**x**；然后，客户端进入**SYN_SEND**状态，等待服务器的确认；
- 第二次握手：服务器收到**SYN**报文段。服务器收到客户端的**SYN**报文段，需要对这个**SYN**报文段进行确认，设置**Acknowledgment Number**为**x+1**(**Sequence Number+1**)；同时，自己自己还要发送**SYN**请求信息，将**SYN**位置为**1**，**Sequence Number**为**y**；服务器端将上述所有信息放到一个报文段（即**SYN+ACK**报文段）中，一并发送给客户端，此时服务器进入**SYN_RECV**状态；
- 第三次握手：客户端收到服务器的**SYN+ACK**报文段。然后将**Acknowledgment Number**设置为**y+1**，向服务器发送**ACK**报文段，这个报文段发送完毕以后，客户端和服务器端都进入**ESTABLISHED**状态，，完成**TCP**三次握手。 完成了三次握手，客户端和服务器端就可以开始传送数据。

```
ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。 TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。（ACK：确认字符）

SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。（SYN：同步序列编号）

FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。
```

#### 发送HTTP请求，服务器处理请求，返回响应结果

**TCP**连接建立后，浏览器就可以利用**HTTP**／**HTTPS**协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如**if-none-match**与**if-modified-since**，则验证缓存是否有效，若有效则返回状态码为**304**，若无效则重新返回资源，状态码为**200**。

#### 关闭TCP连接

![image-20230410171051659](/Users/xiongchao/Library/Application Support/typora-user-images/image-20230410171051659.png)

- 第一次分手：主机**1**（可以使客户端，也可以是服务器端），设置**Sequence Number**和**Acknowledgment Number**，向主机**2**发送一个**FIN**报文段；此时，主机**1**进入**FIN_WAIT_1**状态；这表示主机**1**没有数据要发送给主机**2**了；
- 第二次分手：主机**2**收到了主机**1**发送的**FIN**报文段，向主机**1**回一个**ACK**报文段，**Acknowledgment Number**为**Sequence Number**加**1**；主机1进入**FIN_WAIT_2**状态；主机2告诉主机1，我“同意”你的关闭请求；
- 第三次分手：主机2向主机1发送**FIN**报文段，请求关闭连接，同时主机2进入**LAST_ACK**状态；
- 第四次分手：主机1收到主机2发送的**FIN**报文段，向主机2发送**ACK**报文段，然后主机1进入**TIME_WAIT**状态；主机2收到主机1的**ACK**报文段以后，就关闭连接；此时，主机1等待**2MSL**后依然没有收到回复，则证明**Server**端已正常关闭，那好，主机1也可以关闭连接了。

```
MSL：报文最大生存时间。是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
```

## 为什么“握手”是三次，“挥手”却要四次？

TCP建立连接时之所以只需要"三次握手"，是因为在第二次"握手"过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。

即SYN建立连接报文与ACK确认接收报文是在同一次"握手"当中传输的，所以"三次握手"不多也不少，正好让双方明确彼此信息互通。

TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次"握手"传输的。为何建立连接时一起传输，释放连接时却要分开传输？

- 建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。
- 释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。

## 为什么客户端在TIME-WAIT阶段要等2MSL?

为的是确认服务器端是否收到客户端发出的ACK确认报文

当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。

服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；

- 如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；
- 否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。

所以，客户端要经历时长为2SML的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因

## 为什么很多站点第二次打开速度会很快？

主要原因是第一次加载页面过程中，缓存了一些耗时的数据。 那么，哪些数据会被缓存呢？

#### DNS缓存

主要就是在浏览器本地把对应的 IP 和域名关联起来，这样在进行DNS解析的时候就很快。

#### MemoryCache

是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。

#### 浏览器缓存

浏览器缓存，也称Http缓存，分为强缓存和协商缓存。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。

#### 强缓存

`强缓存`是利用 http 头中的 `Expires` 和 `Cache-Control` 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。

实现强缓存，过去我们一直用expires。当服务器返回响应时，在 Response Headers 中将==过期时间==写入 expires 字段。像这样

```javascript
expires: Wed, 12 Sep 2019 06:12:18 GMT
```

可以看到，==expires 是一个时间戳==，接下来如果我们试图再次向服务器请求资源，浏览器就会先对==比本地时间==和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。

从这样的描述中大家也不难猜测，expires 是有问题的，它最大的问题在于对“本地时间”的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 expires 将无法达到我们的预期。

考虑到 expires 的局限性，HTTP1.1 新增了`Cache-Control`字段来完成 expires 的任务。expires 能做的事情，==Cache-Control== 都能做；expires 完成不了的事情，Cache-Control 也能做。因此，Cache-Control 可以视作是 **expires 的完全替代方案**。在当下的前端实践里，我们继续使用 expires 的唯一目的就是向下兼容。

```javascript
cache-control: max-age=31536000
```

在 Cache-Control 中，我们通过max-age来控制资源的有效期。max-age 不是一个时间戳，而是一个==时间长度==。在本例中，max-age 是 31536000 秒，它意味着该资源在 31536000 秒以内都是有效的，完美地规避了时间戳带来的潜在问题。

`Cache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。`

#### 协商缓存

协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。

协商缓存的实现,从 `Last-Modified` 到 `Etag`,Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：

```javascript
Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT
```

随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：

```javascript
If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT
```

服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。

**使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景：**

- 我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。

- 当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。

这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，`Etag 作为 Last-Modified 的补充出现了。`

==Etag / If-None-Match==

`Etag` 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串可以是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。

Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。

`Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。`

#### Service Worker Cache

Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们==实现离线缓存、消息推送和网络代理==等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。

Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件.

#### Push Cache

Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶段，应用范围有限不代表不重要——HTTP2 是趋势、是未来。在它还未被推而广之的此时此刻，我仍希望大家能对 Push Cache 的关键特性有所了解：

- Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。
- Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。
- 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。 

原文地址：[浏览器相关原理(面试题)详细总结一](https://juejin.cn/post/6844903962216824839#heading-10)

