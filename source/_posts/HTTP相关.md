title: HTTP相关
author: 熊 超
tags:
  - 网络
  - HTTP
categories:
  - 网络
date: 2019-08-07 14:45:00
---
<!-- more --> 

#### 1、http 和 https 的基本概念

​		**http (HyperText Transfer Protocol)**：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的==超文本传输协议==。

​		**https**：是以安全为目标的 HTTP 通道，即 HTTP 下 加入 ==SSL 层进行加密==。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。



##### HTTP + SSL/TLS = HTTPS

**SSL**(Secure Sockets Layer，安全套接字协议)

**TLS**(Transport Layer Security，传输层安全协议)

**HTTP**(HyperText Transfer Protocol ，超文本传输协议)，让计算机之间可以进行明文数据交换，默认端口80.

**HTTPS**(HyperText Transfer Protocol Secure，超文本传输安全协议)，用SSL/TLS对数据加密，再通过HTTP传输，保证数据的安全性，默认端口443.

TLS是基于SSL 3.0的一个新版本，原则上他的名字是SSL 4.0；只是IETF在把SSL标准化时把SSL名称改成了TLS。



#### 2、HTTP

​		在实际应用中，`HTTP`常被用于在`Web`浏览器和网站服务器之间传递信息，以**明文方式发送内容**，不提供任何方式的数据加密。

特点如下：

- 支持客户/服务器模式；
- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。**==由于`HTTP`协议简单==**，使得HTTP服务器的程序规模小，因而**==通信速度很快==**；
- 灵活：`HTTP`**==允许传输任意类型的数据对象==**。正在传输的类型由`Content-Type`加以标记；
- 无连接：无连接的含义是**==限制每次连接只处理一个请求==**。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间;
- 无状态：`HTTP`协议**无法根据之前的状态**进行本次的请求处理;



#### 3、HTTPS

​		在上述介绍`HTTP`中，了解到`HTTP`传递信息是以明文的形式发送内容，这并不安全。而`HTTPS`出现正是为了解决`HTTP`不安全的特性。

​		为了保证这些隐私数据能加密传输，让`HTTP`运行安全的`SSL/TLS`协议上，即 ==HTTPS = HTTP + SSL/TLS==，通过 `SSL`证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。

​		`SSL` 协议位于`TCP/IP` 协议与各种应用层协议之间，浏览器和服务器在使用 `SSL` 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持

**流程如下**：

- 客户端向服务器发起 HTTPS 请求，请求中包含了 SSL/TLS 支持的信息，比如支持的 SSL/TLS 版本号、加密算法等。
- 服务器返回证书给客户端，证书中包含了服务器的公钥、服务器的身份信息和证书的有效期等。
- 客户端验证服务器的身份，包括验证证书的有效性、证书是否过期、证书中的域名与服务器的域名是否一致等。
- 如果证书验证通过，客户端生成一个随机的加密密钥，并使用服务器的公钥进行加密，然后发送给服务器。
- 服务器使用私钥解密客户端发来的密钥，然后生成一个随机数作为会话密钥，并将会话密钥加密后发送给客户端。
- 客户端和服务器使用会话密钥进行数据传输，客户端和服务器之间的所有数据都使用会话密钥进行加密和解密，保证数据的机密性和完整性。

##### 简洁版：

1. 客户端使用https的url访问web服务器,要求与服务器建立ssl连接
2. web服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端
3. 客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥
4. 客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥
5. 之后服务器与客户端使用秘钥加密传输



#### 4、http 和 https 的区别及优缺点

- http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议`安全`，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。
- http 协议的`默认端口`为 80，https 的默认端口为 443。
- http 的连接很简单，是无状态的。https 握手阶段比较`费时`，会使页面加载时间延长 50%，增加 10%~20%的耗电。
- https `缓存`不如 http 高效，会增加数据开销。
- Https 协议需要 ca 证书，费用较高，功能越强大的`证书费`用越高。
- SSL 证书需要绑定 `IP`，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。



#### 5、http1和http1.1的区别

1. ==持久连接==：

   - HTTP / 1.1引入了持久连接，这意味着在单个TCP连接上可以发送多个请求/响应对，从而减少了每个请求的延迟。
   - HTTP / 1.0在每个请求/响应之后关闭TCP连接。

2. ==块传输编码==：

   ​		HTTP / 1.1支持块传输编码，这意味着可以在接收响应时逐步解压缩数据，而不必等待整个响应。这对于处理大型响应或流式数据非常有用。

3. ==身份验证==：

   ​		HTTP / 1.1提供了更安全的身份验证方法，例如基于令牌的身份验证方案，可以替代HTTP / 1.0中的基本身份验证。

4. ==缓存处理==：

   ​	HTTP / 1.1对缓存处理进行了改进，包括新的Cache-Control指令，可以更好地控制缓存行为。

5. ==响应码==：

   ​	HTTP / 1.1引入了更多的响应码，例如“100 Continue”，这使得客户端可以更好地控制它们的请求行为。

6. ==管道化==：

   ​	HTTP / 1.1支持管道化，允许客户端同时发送多个请求，从而提高性能。



#### 6、GET 和 POST 的区别

##### 1. POST请求相对安全，GET请求相对不安全

- GET请求参数会直接挂载在URL上。POST请求携带的参数在URL上看不见。
- POST请求记录不会被保存在浏览器历史或web服务器日志中。但是GET请求会。

当然，以上是相对的。这不表示POST请求就绝对安全，其实。

从数据传输的角度来说，*POST和GET都不是很安全*，因为**http协议本身是明文传输**。对内行人来说，抓包解析GET和POST都是一样的。



##### 2. GET请求可以缓存，POST请求不能缓存

​		GET请求一般用于数据和**静态资源的获取**，*有些GET请求不用和数据库交互*。比如一些静态资源和固定的字典表。所以可以使用缓存。

数据缓存👇

![image-20230411143847289](/Users/xiongchao/Library/Application Support/typora-user-images/image-20230411143847289.png)

静态资源缓存👇

![image-20230411143907562](/Users/xiongchao/Library/Application Support/typora-user-images/image-20230411143907562.png)

POST请求则更多用于数据的新增和修改。新增数据无法具备固定内容。所以很多浏览器都不支持缓存POST请求



##### 3. GET请求有长度限制，POST请求没有长度限制

*GET请求本身是没有长度限制的*，但是URL有。不同的浏览器对于GET的长度限制也不一样。



##### 4. GET只能传输字符串，POST可以传输多种类型数据

​		因为GET请求是挂载在URL上的，所以传输的数据类型只能是字符串，但是POST请求可以传输除字符串以外的数据，比如：视频，声音，图片，文档等。



##### 5. GET请求入参在URL上，POST请求入参在Request body上

​		

##### 6. POST*有可能*产生两个数据包，GET只会发送一个数据包

​		GET请求在任何情况下都会把http header和data一次性发送完成。

​		POST在*部分情况下*，（这取决于 浏览器/发送方 和它的版本），会产生两个数据包。第一个tcp发送header,确认服务器可以响应并且具备接受数据的能力，响应100。第二个TCP包在第一个请求成功（100后）才会发送。包含data。如果第一个请求（header）失败，则data不进行发送。



##### 7.  刷新和回退的时候GET请求无害，POST数据会被重新提交

​		以前我一直没搞明白这一点区别的含义，怎么GET就无害了，POST就又会重新提交了。后来我明白了。

​		这点区别指向的是那些页面加载时候就默认执行的请求。

​		比如静态资源获取，刷新了就得重新加载吧。如果是GET，GET主要用重新获取数据，因为是获取，请求不会对数据产生什么危害，何况有时候还直接返回的缓存。所以无害。

​		再说POST，POST主要用于数据的修改/新增，针对默认执行的情况下，POST请求的每次执行都有可能改变数据库中的某一个值，比如文章的阅读量。刷新一下就+1（不信你刷一个试试）。所以这里说POST数据会被重新提交，这种提交他不一定有害，但确实不一定有用。



#### 7、HTTP状态码

##### 使用场景:

- 1xx：表示目前是协议的中间状态，还需要后续请求。
- 2xx：表示请求成功。
- 3xx：表示重定向状态，需要重新请求。
- 4xx：表示请求报文错误。
- 5xx：服务器端错误。

##### 常用状态码：

- 101 切换请求协议，从 HTTP 切换到 WebSocket
- 200 请求成功，有响应体，服务器成功返回网页
- 301 永久重定向：会缓存
- 302 临时重定向：不会缓存
- 304 协商缓存命中
- 403 服务器禁止访问
- 404 资源未找到，请求的网页不存在
- 400 请求错误
- 500 服务器端错误
- 503 服务器繁忙



#### 8、跨域解决方案

##### 8.1 JSONP

`JSONP` 主要就是利用了 `script` 标签没有跨域限制的这个特性来完成的。

仅支持 GET 方法，如果想使用完整的 REST 接口，请使用 CORS 或者其他代理方式。

后端获取前端声明的执行函数（jsonpCallback），并以带上参数并调用执行函数的方式传递给前端。

```js
function callback(){
    console.log("月薪一千五，心比美式苦")
}

$.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp  设置跨域的重点
    jsonpCallback: "callBack",  // 回调函数
});
```



##### 8.2 添加Access-Control-Allow-Origin响应头

```js
res.writeHead(200, {
    Access-Control-Allow-Origin':'http://192.168.0.103:8080'
		// 或者
    Access-Control-Allow-Origin':'*'
});
```



##### 8.3 前端工具的Proxy代理

```js
devServer: {
  port: 8000,
    proxy: {
      "/api": {
        target: "http://localhost:8080"
      }
    }
},
```



##### 8.4 Nginx 反向代理

```nginx
server {
  listen 80;
  server_name local.test;
  location /api {
    proxy_pass http://localhost:8080;
  }
  location / {
    proxy_pass http://localhost:8000;
  }
}
```



##### 8.5 Websocket

[WebSocket](https://link.juejin.cn/?target=http%3A%2F%2Fdev.w3.org%2Fhtml5%2Fwebsockets%2F) 规范定义了一种 API，可在网络浏览器和服务器之间建立“套接字”连接。简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据

这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制。



##### 8.6 document.domain + Iframe

**「该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式」**。 只需要给页面添加 `document.domain ='test.com'` 表示二级域名都相同就可以实现跨域。

```erlang
www.   baidu.  com     .
三级域  二级域   顶级域   根域
```

##### 8.7 window.location.hash + Iframe

##### 8.8 window.name + Iframe